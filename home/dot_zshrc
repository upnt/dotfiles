# load functions
fpath+="$HOME/.zsh_functions"

# load envs
if [[ -d "$PYENV_ROOT" ]]; then
    fpath+="$PYENV_ROOT/completions"
    eval "$(pyenv init -)"
	eval "$(pyenv virtualenv-init -)"
fi

if [[ -d "$NODENV_ROOT" ]]; then
    fpath+="$NODENV_ROOT/completions"
    eval "$(nodenv init - zsh)"
fi

if [[ -d "$RBENV_ROOT" ]]; then
    fpath+="$RBENV_ROOT/completions"
    eval "$(rbenv init -)"
fi

if [[ -d "$LUAENV_ROOT" ]]; then
    fpath+="$LUAENV_ROOT/completions"
    eval "$(luaenv init -)"
fi

if [[ -d "$JENV_ROOT" ]]; then
    fpath+="$JENV_ROOT/completions"
    eval "$(jenv init -)"
    jenv enable-plugin export
fi

if [[ -d "$PLENV_ROOT" ]]; then
    eval "$(plenv init -)"
fi

# Set up the prompt
autoload -Uz promptinit
promptinit
prompt adam1

setopt histignorealldups sharehistory

# Use emacs keybindings even if our EDITOR is set to vi
bindkey -e

# Keep 1000 lines of history within the shell and save it to ~/.zsh_history:
HISTSIZE=1000
SAVEHIST=1000
HISTFILE=~/.zsh_history

# Use modern completion system
autoload -Uz compinit
compinit

zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _correct _approximate
zstyle ':completion:*' format 'Completing %d'
zstyle ':completion:*' group-name ''
zstyle ':completion:*' menu select=2
eval "$(dircolors -b)"
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
zstyle ':completion:*' menu select=long
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' use-compctl false
zstyle ':completion:*' verbose true

zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'

prompt_precmd() {
    local red=$'\e[31m' green=$'\e[32m' yellow=$'\e[33m'
    local blue=$'\e[34m' magenta=$'\e[35m'
    local cyan=$'\e[36m' reset=$'\e[m'
    local branch_icon=$'\ue725'
    local branch="$(git branch --show-current 2> /dev/null)"
    PROMPT=$'\n'
    if [ -n "$VIRTUAL_ENV_PROMPT" ]; then
        PROMPT+="%B%{${green}%}${VIRTUAL_ENV_PROMPT}%{${reset}%}%b"$'\n'
    fi
    PROMPT+="%B%{${cyan}%}%~%{${reset}%}%b"
    if [ -n "$branch" ]; then
        PROMPT+=" on %B%{${red}%}${branch_icon} ${branch}%{${reset}%}%b"
    fi
    PROMPT+=$'\n'"%B"$'\u232A'"%b"
}

autoload -Uz add-zsh-hook
add-zsh-hook precmd prompt_precmd

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias lt='ls --tree'
    alias rls='ls --color=auto | shuf | head -n 1'
    alias rcd='cd $(ls --color=never | shuf | head -n 1)'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# alias
# update exit function
function confirm_exit() {
  local last_status=$?
  local last_pane=false
  if [[ -n $TMUX ]]; then
    if [ "$(tmux list-windows | wc -l)" -eq 1 ]; then
      if [ "$(tmux list-panes | wc -l)" -eq 1 ]; then
        last_pane=true
      fi
    fi
  fi
  
  if "${last_pane}"; then
    echo -n "セッションを終了しますか？(y/N): "
    read answer
    if [[ "$answer" == "y" ]]; then
      builtin exit $last_status
    fi
  else
      builtin exit $last_status
  fi
}

alias exit=confirm_exit

if type "bat" > /dev/null 2>&1; then
    alias cat='bat'
fi
if type "rg" > /dev/null 2>&1; then
    alias grep='rg'
fi
if type "fd" > /dev/null 2>&1; then
    alias find='fd'
fi
if type "lsd" > /dev/null 2>&1; then
    alias ls='lsd -l --blocks "git,user,group,name"'
    alias la='ls -A'
    alias ll='lsd -alF'
else
    alias ll='ls -alF'
    alias la='ls -A'
fi

if type "zoxide" > /dev/null 2>&1; then
    eval "$(zoxide init zsh)"
    alias cd="z"
fi

if [[ -d "$HOME/.fzf" ]]; then
    source <(fzf --zsh)
    if [[ -n "$TMUX" ]]; then
        alias fzf="$HOME/.fzf/bin/fzf-tmux -p 90%"
    fi
    
    function fe {
        local file=`find . -t f -p --hidden --exclude=".git/" --color=always |
        sed -e 's#\\\\#/#g' |
        fzf --ansi --reverse --preview 'bat --color=always {}' --preview-window=up:60%`
        if [ -n "$file" ]; then
            $EDITOR $file
        fi
    }

    function fdiff {
        local file=`find . -t f -p --hidden --color=always --exclude=".git/" |
        sed -e 's#\\\\#/#g' |
        fzf --ansi --reverse --preview "git diff $@ {}" --preview-window=up:60%`
        if [ -n "$file" ]; then
            git diff $@ $file
        fi
    }
    
    function fcm {
        local pane=`tmux ls -F '[#{session_windows}] #S' |
        fzf --ansi --preview 'echo {} | cut -d " " -f 2- | xargs tmux capture-pane -ep -t | cat' |
        cut -d ' ' -f 2-`
        
        # if you in tmux sesion
        local in_tmux
        [[ -n "$TMUX" ]] && in_tmux=0 || in_tmux=1

        if [[ -n "$pane" ]];
            if [[ $in_tmux == 0 ]] ; then
                tmux switch-client -t $pane
            else;
                tmux attach-session -t $pane
        fi
    }


    function gclone {
        local repos=`gh repo list --json "nameWithOwner" | jq -r '.[]["nameWithOwner"]'`
        if [ "$1" = "-a" ] || [ "$1" = "--all" ]; then
            for i in `gh org list`
            do
                local buf=`gh repo list $i --json "nameWithOwner" | jq -r '.[]["nameWithOwner"]'`
                if [ ! "$buf" = "" ]; then
                    repos="${repos}\n${buf}"
                fi
            done
        fi
        local repo=`echo $repos | fzf --ansi --reverse | cut -f 1`
        if [ ! "$repo" = "" ]; then
            gh repo clone "$repo" $@
        fi
        echo $repo
    }
    
    function git-uploaded {
        if [ -n "$(git status -s)" ]; then
            echo "There are uncommited files"
        fi
        if [ -n "$(git status | grep 'ahead of')" ]; then
            echo "There are unpushed files"
        fi
        return 0
    }

    function _ftm_list() {
        local _project_list
        local _project_status
        _project_list=()
        while read -r line; do
            IFS=" " read -r _tmp _dir <<< "$line"
            cd $(eval echo "$_dir") || continue
            if [ -n "$(git-uploaded)" ]; then
                _project_status="*"
            else
                _project_status=" "
            fi
            _project_list+=("${_project_status} [alias] ${_tmp}")
            cd - &> /dev/null || return
        done < <(awk -F, '{print $1,$2}' "$GHUX_ALIASES_PATH")
        while read -r line; do
            _dir="$(ghq root)/$line"
            cd $_dir || continue
            git status -s
            if [ -n "$(git-uploaded)" ]; then
                _project_status="*"
            else
                _project_status=" "
            fi
            _project_list+=("${_project_status} ${line}")
            cd - &> /dev/null || return
        done < <(ghq list | sort -r)
        IFS=$'\n'
        echo "${_project_list[*]}"
    }

    function ftm() {
        local project_name  
        local project_dir
        local project_list
        project_list="$(_ftm_list)"
        project_list="  [create] new repository\n$project_list"
        if ( type gclone &> /dev/null ); then
            project_list="  [create] clone from github\n$project_list"
        fi
    
        project_dir=$(echo $project_list|fzf)
    
        if [[ -z $project_dir ]]; then
            [[ -n $CURSOR ]] && zle redisplay
            return 1
        fi
    
        if (echo ${project_dir:2} | /usr/bin/grep -E "^\[alias\]" &>/dev/null);then
            project_name=${project_dir:10}
            line=( `/usr/bin/cat $GHUX_ALIASES_PATH|/usr/bin/grep -E "${project_name}," | /usr/bin/cut -d',' -f2` )
            project_dir="$(eval echo ${line[1]})"
        elif (echo ${project_dir:2} | /usr/bin/grep -E "^\[create\]" &>/dev/null); then
            if (echo ${project_dir:2} | /usr/bin/grep -E "github" &>/dev/null); then
                cd $(ghq root); project_name=$(gclone); cd - &>/dev/null
                project_name=${project_name##*/}
                project_dir=$(ghq root)/$project_name
            else
                read project_name"?project name: "
                project_dir=$(ghq root)/$project_name
                if [ ! -d "$project_dir" ]; then
                    mkdir $project_dir
                    cd $project_dir; git init; cd - &>/dev/null
                else;
                    echo "${project_dir} already exists"
                fi
            fi
        else
            project_dir=$(ghq root)/${project_dir:2}
            project_name=$(echo $project_dir | /usr/bin/rev | /usr/bin/awk -F \/ '{printf "%s", $1}' | /usr/bin/rev | /usr/bin/awk '{sub("\\.",""); print $0}')
        fi
    
        # if you in tmux sesion
        local in_tmux
        [[ -n $TMUX ]] && in_tmux=0 || in_tmux=1
    
        local tmux_list=$(tmux list-session 2>/dev/null)
    
        # tmuxに既にfzfで選択したプロジェクトのセッションが存在するかどうか
        if  ! (echo $tmux_list | /usr/bin/grep -E "^$project_name" &>/dev/null); then
            (cd $(eval echo ${project_dir}) && TMUX=; tmux new-session -ds $project_name 2>/dev/null) > /dev/null # cdした後lsしちゃうので
        fi
    
    
        if [[ $in_tmux == 0 ]] ; then
            if [[ -n "$CONTEXT" ]]; then
                BUFFER="tmux switch-client -t $project_name"&& zle accept-line && zle redisplay
            elif [[ -n "$project_name" ]]; then
                tmux switch-client -t $project_name
            fi
        else;
            
            if [[ -n "$CONTEXT" ]]; then
                BUFFER="tmux attach-session -t $project_name"&& zle accept-line && zle redisplay
            elif [[ -n "$project_name" ]]; then
                tmux attach-session -t $project_name
            fi
        fi
    }

    zle -N ghux
fi

# config
# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

[[ -f "$HOME/.local/.zshrc" ]] && source "$HOME/.local/.zshrc"
